<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaEE-Spring框架之IOC容器入门以及DI注入(一)]]></title>
    <url>%2FJavaEE-Spring%E6%A1%86%E6%9E%B6%E4%B9%8BIOC%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8%E4%BB%A5%E5%8F%8ADI%E6%B3%A8%E5%85%A5%E4%B8%80%2F</url>
    <content type="text"><![CDATA[No.1 框架概述与Spring重要性什么是框架？ 框架是软件的半成品，已经预先提供了一些功能，我们在框架的基础上做开发，框架已经有的功能可以直接使用。 框架的好处 简化开发 1.简化开发，因为已经提供了一些功能的实现； 2.框架是优秀的程序员写出的优秀的代码形成的工具类，具有可扩展性，设计优良. 3.优秀的开源框架，大家都比较熟悉，更适合团队开发。 三层架构与常见的框架 Web层（表现层） SpringMVC Struts2 Service层（业务层） Spring Dao层（持久层） JdbcTemplae(Spring) MyBatis Hibernate/Jpa/SpringDataJpa Spring框架在JavaEE的三层架构中都可以完成对应功能开发！！ Spring重要性 Spring是一个家族体系，可以完成JavaEE开发中几乎所有问题！！（Spring会一统Java的天下） https://spring.io/projects Spring Framework (spring框架 IOC AOP 事务管理，SpringMVC等) Spring Security（权限校验） Spring Data( 一统持久层天下 mysql，oracle，mongoDB，solr等 ) Spring Boot（简化Spring开发） Spring Cloud（分布式开发） Spring AMQP（整合RabbitMQ 消息队列） 。。。。。。 No.2 Spring（Framework）介绍简介: Spring （Framework）框架拥有7个核心模块，都是为JavaEE开发提供基础功能。 体系结构 Spring Core（IOC容器）：创建对象，给对象属性赋值 Spring AOP（面向切面编程）： 事务管理，自定义AOP编程 Spring ORM：Spring整合ORM框架（Hibernate/JPA） Spring JDBC： 提供JdbcTemplate的，对Jdbc简单封装 Spring Web：Spring整合Web（Servlet，Filter） SpringMVC：Spring提供MVC表现层模块 Spring Context： 国际化，事件驱动编程 IOC容器的好处：解耦 No.3 程序中解耦应用-工厂模式解耦 需求： 由于客户的数据库环境经常变化，希望更换数据库时候，只需要修改dao的代码，不需要修改service。 代码实现 1）Idea工具创建项目Maven项目 2）编写Dao接口和实现 123456789package com.gemin.dao;/** * */public interface UserDao &#123; public void save();&#125; 12345678910111213package com.gemin.dao.impl;import com.gemin.dao.UserDao;/** * mysql的Dao实现 */public class UserDaoMySQLImpl implements UserDao &#123; @Override public void save() &#123; System.out.println("用户已经保存到mysql数据库"); &#125;&#125; 3）编写Service接口和实现 12345678910package com.gemin.service;/** * */public interface UserService &#123; public void save(); &#125; 1234567891011121314151617181920package com.gemin.service.impl;import com.gemin.dao.UserDao;import com.gemin.dao.impl.UserDaoMySQLImpl;import com.gemin.service.UserService;/** * */public class UserServiceImpl implements UserService &#123; //创建Dao实现类对象（依赖、耦合） private UserDao userDao = new UserDaoMySQLImpl(); @Override public void save() &#123; userDao.save(); &#125;&#125; 4）编写测试类 123456789101112131415161718package com.gemin.test;import com.gemin.service.UserService;import com.gemin.service.impl.UserServiceImpl;/** * */public class UserServiceTest &#123; public static void main(String[] args) &#123; //1.创建Service对象 UserService userService = new UserServiceImpl(); //2.调用service方法 userService.save(); &#125; &#125; 5）运行测试 这时，项目数据需要从mysql迁移到oracle,意味Dao实现需要更新，但为了遵守开闭原则，我们新建UserDaoOracleImpl进行扩展，但是业务层的UserServiceImpl需要修改代码来切换Dao实现 我们发现，如果每次Dao进行扩展了，Service需要修改源代码，这种做法耦合度比较高！！！ 那么怎么呢？ 可以使用工厂模式解决Service和Dao的耦合问题！！！！ 6）设计一个BeanFactory工厂类 12345678910111213141516171819package com.gemin.factory;import com.gemin.dao.UserDao;import com.gemin.dao.impl.UserDaoOracleImpl;/** * 用于创建对象的工厂类 */public class BeanFactory &#123; /** * 提供创建对象的方法 */ public static UserDao getBean()&#123; return new UserDaoOracleImpl(); &#125;&#125; 7）利用工厂来解耦 但是，还是工厂类 不够灵活（每次修改代码），这时优化BeanFactory 8）建立bean.properties，描述了所有可以创建的对象 9）改造BeanFactory 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.gemin.factory;import com.gemin.dao.UserDao;import com.gemin.dao.impl.UserDaoMySQLImpl;import com.gemin.dao.impl.UserDaoOracleImpl;import java.util.ResourceBundle;/** * 用于创建对象的工厂类 */public class BeanFactory &#123; //使用ResourceBundle读取properties private static ResourceBundle bundle; /* *//** * 提供创建对象的方法 *//* public static UserDao getBean()&#123; return new UserDaoMySQLImpl(); &#125;*/ /** * 读取bean.properties来创建对象 */ public static Object getBean(String key)&#123; if(bundle==null) &#123; //1.加载bean.properties //getBundle: 传入properties文件的名称（不需要后缀），用于加载该文件 bundle = ResourceBundle.getBundle("bean"); &#125; //2.根据传入的key找到vlaue(value只类的全名) String className = bundle.getString(key); //3.使用反射创建类的对象 Class&lt;?&gt; clazz = null; try &#123; clazz = Class.forName(className); Object object = clazz.newInstance(); //4.返回 return object; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125; 10）Service改造 到这里，任务完成啦，通过工厂模式+配置 最终实现Service和Dao 解耦啦！！！！ No.4 程序中解耦应用-控制反转什么是IOC和DI？ IOC，Inverse Of Control 控制反转，把创建对象的权力，由自己创建(new)改为工厂来创建。解决创建对象的耦合问题！！！ DI，Denpedency Injection 依赖注入，把对象属性赋值的权力，由自己完成改为工厂来完成。解决给对象属性赋值的耦合问题！！！ 创建对象和属性赋值的细节？ 创建对象（IOC）的细节： ​ 1）创建的对象是单例还是多例？ ​ 2）创建对象的时机问题（延迟创建） ​ 3）创建对象的生命周期问题 给对象属性（DI）赋值的细节 ​ 1）可以怎么赋值？赋值的方式？ ​ 2）可以赋什么类型的值？ 基本类型，集合，Java对象等 No.5 SpringIOC容器(一)入门案例步骤 1.创建项目，导入spring-context（IOC依赖） 2.编写User类 3.编写bean.xml声明对象的创建 4.测试 实现 1.创建项目，导入spring-context（IOC依赖） 1234567891011&lt;dependencies&gt; &lt;!-- Spring IOC容器 注意：以后导入Spring的其他模块都必须统一版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.编写User类 123456789101112package com.gemin.pojo;/** * 用户实体类 */public class User &#123; public User()&#123; System.out.println("创建了User对象!"); &#125;&#125; 3.编写bean.xml声明对象的创建（***） spring配置文件 名称：建议叫bean.xml 或 applicationContext.xml 位置: 放在类路径， resources目录下 内容如下： 找到约束内容 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 创建User对象 --&gt; &lt;!-- id: 给创建的对象一个别名（必须唯一的） class: 需要创建类的全名 --&gt; &lt;bean id="user" class="com.gemin.pojo.User"&gt;&lt;/bean&gt; &lt;/beans&gt; 4.测试 先导入junit依赖 1234567891011121314151617&lt;dependencies&gt; &lt;!-- Spring IOC容器 注意：以后导入Spring的其他模块都必须统一版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 123456789101112131415161718192021222324package com.gemin.test;import com.gemin.pojo.User;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Spring IOC入门 */public class Demo1 &#123; @Test public void test1()&#123; //1.创建IOC容器（bean工厂） 类路径方式加载 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.从IOC容器获取对象 User user = (User)ac.getBean("user"); //3.输出 System.out.println(user); &#125;&#125; 输出结果： 小结 导入spring-context依赖（IOC容器） 编写bean.xml 声明对象的创建： 测试代码 创建ApplicationContext对象 （IOC容器） 使用getBean方法从IOC容器获取对象 No.6 SpringIOC容器(二)创建对象细节bean标签配置细节 创建对象（IOC）的细节： ​ 1）创建的对象是单例还是多例？ ​ 2）创建对象的时机问题（延迟创建） ​ 3）创建对象的生命周期问题 代码 1.bean.xml配置细节 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 创建User对象 --&gt; &lt;!-- id: 给创建的对象一个别名（必须唯一的） class: 需要创建类的全名 --&gt; &lt;!-- &lt;bean id="user2" class="com.gemin.pojo.User"&gt;&lt;/bean&gt;--&gt; &lt;!-- bean的配置细节 1) id: 给创建的对象一个别名（必须唯一的） (推荐使用) *** 2) class: 需要创建类的全名（注意必须是类的全名） *** 3) name: 给创建的对象创建多个别名，别名之间使用,逗号隔开 4) scope： 创建对象的作用域，创建单例对象还是多例对象 *** singleton: 单例的，默认值。每次调用getBean方法获取的对象都是同一个！！！ *** prototype: 多例的。每次调用getBean方法都会创建一个新的对象！！ request: web中使用。每个用户的请求都会创建一个新的对象！！！ session: web中使用。每个session会话中都会创建一个新的对象！！！ glbalsession： web中使用。在web集群环境中使用，在同一个集群环境下，只会有一个对象！！ 5)lazy-init: 是否延迟创建对象。 false: 不延迟，默认值。在创建IOC容器的时候，就会根据bean配置创建好对象，等待程序来获取 true: 延迟。在创建IOC容器的时候，先不创建对象，等到程序来获取（getBean）的时候再创建对象 6) init-method和destroy-method： 对象的生命周期方法 init-method： 初始化方法。在创建完对象后立即调用init-method destroy-method： 销毁方法。在销毁对象之前调用destroy-method --&gt; &lt;bean id="user" class="com.gemin.pojo.User" name="user3,user4" scope="singleton" lazy-init="true" init-method="init" destroy-method="preDestory"&gt;&lt;/bean&gt;&lt;/beans&gt; 2.测试代码 12345678910111213141516171819202122232425262728293031323334//演示单例或多例@Testpublic void test2()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //从IOC容器获取多次的对象 for(int i=1;i&lt;=5;i++) &#123; User user = (User) ac.getBean("user"); System.out.println(user); &#125;&#125;//演示是否延迟创建对象@Testpublic void test3()&#123; //1.创建IOC容器（bean工厂） 类路径方式加载 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.从IOC容器获取对象 User user = (User)ac.getBean("user"); //3.输出 System.out.println(user);&#125;//演示对象的生命周期方法@Testpublic void test4()&#123; //1.创建IOC容器（bean工厂） 类路径方式加载 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.从IOC容器获取对象 User user = (User)ac.getBean("user"); //3.输出 System.out.println(user); //4.销毁IOC容器（关闭IOC） ac.close();&#125; No.7 SpringIOC容器(三)创建容器几种方式目标 容器接口结构图 代码实现不同的方式创建容器 容器接口结构图 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.gemin.test;import com.gemin.pojo.User;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;/** * 演示创建IOC容器的方式 */public class Demo2 &#123; /** * 文件路径方式创建IOC容器： * 1. 绝对路径：E:\tensquare_codes\javacode_113\javaee113\spring01_02_ioc\src\main\resources * 2. 相对路径： 从项目的src目录开始查询 */ //绝对路径 @Test public void test1()&#123; ApplicationContext ac = new FileSystemXmlApplicationContext("E:\\tensquare_codes\\javacode_113\\javaee113\\spring01_02_ioc\\src\\main\\resources\\bean.xml"); User user = (User)ac.getBean("user"); System.out.println(user); &#125; //相对路径 @Test public void test2()&#123; ApplicationContext ac = new FileSystemXmlApplicationContext("src/main/resources/bean.xml"); User user = (User)ac.getBean("user"); System.out.println(user); &#125; // 使用类路径方式： 项目的类路径，就是在resources目录下 （推荐使用） @Test public void test3()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); User user = (User)ac.getBean("user"); System.out.println(user); &#125;&#125; No.8 SpringIOC容器(四)创建对象的三种方式目标 掌握创建对象的三种方式： 方式1：默认无参数构造函数创建对象（推荐方式） 方式2：工厂类的静态方法创建对象 方式3：工厂类的实例方法创建对象 默认无参数构造函数创建对象（最常用） 步骤： 1.配置bean.xml 2.编写Person类 3.测试 实现： 1.bean.xml配置（***） 使用IDEA创建spirng配置文件 2.Person类（***） 3.测试 12345678910111213141516171819202122package com.gemin.test;import com.gemin.pojo.Person;import com.gemin.pojo.User;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;/** * 演示IOC容器创建对象的三种的方式 */public class Demo3 &#123; @Test public void test1()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean_ioc.xml"); Person person = (Person)ac.getBean("person"); System.out.println(person); &#125;&#125; 工厂类的静态方法创建对象 步骤： 1.编写工厂类，提供静态方法 2.配置bean.xml 3.测试 实现： 1.编写工厂类，提供静态方法 123456789101112131415package com.gemin.pojo;/** * 工厂类 */public class PersonFactory &#123; /** * 静态方法 */ public static Person getPersonByStatic()&#123; return new Person(); &#125;&#125; 2.配置bean.xml 3.测试 12345678910111213141516171819202122package com.gemin.test;import com.gemin.pojo.Person;import com.gemin.pojo.User;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;/** * 演示IOC容器创建对象的三种的方式 */public class Demo3 &#123; @Test public void test1()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean_ioc.xml"); Person person = (Person)ac.getBean("person"); System.out.println(person); &#125;&#125; 工厂类的实例方法创建对象 步骤：1.在工厂类添加实例方法 2.配置bean.xml 3.测试 实现： 1.在工厂类添加实例方法 2.配置bean.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- IOC容器创建对象的三种方式 --&gt; &lt;!-- 1. 默认无参的构造方式 注意：需要创建的对象必须提供无参构造方式 --&gt; &lt;!-- &lt;bean id="person" class="com.gemin.pojo.Person"/&gt;--&gt; &lt;!-- 2.工厂类的静态方法 --&gt; &lt;!-- 底层： Person person = PersonFactory.getPersonByStatic(); class: 工厂类的全名 factory-method: 工厂类的一个静态方法名称 --&gt; &lt;!--&lt;bean id="person" class="com.gemin.pojo.PersonFactory" factory-method="getPersonByStatic"&gt;&lt;/bean&gt;--&gt; &lt;!-- 3. 工厂类的实例方法 --&gt; &lt;!-- 底层： PersonFactory factory = new PersonFactory(); Person person = factory.getPerson(); --&gt; &lt;!-- 3.1 先创建工厂类对象 --&gt; &lt;bean id="factory" class="com.gemin.pojo.PersonFactory"/&gt; &lt;!-- 3.2 使用工厂对象调用实例发方法 factory-bean: 创建工厂对象的id factory-method: 工厂类的实例方法 --&gt; &lt;bean id="person" factory-bean="factory" factory-method="getPerson"/&gt; &lt;/beans&gt; 3.测试 12345678910111213141516171819202122package com.gemin.test;import com.gemin.pojo.Person;import com.gemin.pojo.User;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;/** * 演示IOC容器创建对象的三种的方式 */public class Demo3 &#123; @Test public void test1()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean_ioc.xml"); Person person = (Person)ac.getBean("person"); System.out.println(person); &#125;&#125; No.9 SpringIOC容器(五)依赖注入A-带参数构造函数什么是依赖注入？ DI, 依赖注入，关注的就是怎么给对象的属性去赋值！！！ DI的细节？ 1）有什么方式可以给属性赋值？ 2）有哪些属性的类型可以赋值？ 构造器赋值 步骤： 1.在Person类添加带参数的构造方式 2.配置bean.xml 3.测试 实现： 1.在Person类添加带参数的构造方式 2.配置bean.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 依赖注入：给对象属性赋值 --&gt; &lt;!-- 1. 带参数的构造方式--&gt; &lt;!-- constructor-arg 标签的使用 1）value： 需要传递的参数值（仅限基本类型） 2) index: 参数的索引号，从0开始，不写index，按照配置从下往下的顺序加载 3) name: 指定方法的形参名称来进行赋值， 不写，就自动匹配形式参数名称 4）type: 指定方法的参数类型赋值, 默认不写就是String类型 5) ref: 引用类型，引用IOC容器的另一个bean（对象） 注意：value和ref只能使用其中一个 --&gt; &lt;bean id="person" class="com.gemin.pojo.Person"&gt; &lt;!-- 给构造方式传入参数 --&gt; &lt;constructor-arg value="10" type="int"/&gt; &lt;constructor-arg ref="str"/&gt; &lt;/bean&gt; &lt;!-- 创建String对象 --&gt; &lt;!-- 底层： String str = new String("小泽"); --&gt; &lt;bean id="str" class="java.lang.String"&gt; &lt;constructor-arg value="小泽"/&gt; &lt;/bean&gt;&lt;/beans&gt; 3.测试 1234567891011121314151617181920package com.gemin.test;import com.gemin.pojo.Person;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 演示依赖注入 */public class Demo4 &#123; @Test public void test1()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean_di.xml"); Person person = (Person)ac.getBean("person"); System.out.println(person); &#125;&#125; No.10 SpringIOC容器(六)依赖注入B-set方法步骤 1.在Person类提供setter方法 2.配置bean.xml 3.测试 实现 1.在Person类提供setter方法 2.配置bean.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 依赖注入：给对象属性赋值 --&gt; &lt;!-- 1. 带参数的构造方式--&gt; &lt;!-- constructor-arg 标签的使用 1）value： 需要传递的参数值（仅限基本类型） 2) index: 参数的索引号，从0开始，不写index，按照配置从下往下的顺序加载 3) name: 指定方法的形参名称来进行赋值， 不写，就自动匹配形式参数名称 4）type: 指定方法的参数类型赋值, 默认不写就是String类型 5) ref: 引用类型，引用IOC容器的另一个bean（对象） 注意：value和ref只能使用其中一个 --&gt; &lt;bean id="person2" class="com.gemin.pojo.Person"&gt; &lt;!-- 给构造方式传入参数 --&gt; &lt;constructor-arg value="10" type="int"/&gt; &lt;constructor-arg ref="str"/&gt; &lt;/bean&gt; &lt;!-- 创建String对象 --&gt; &lt;!-- 底层： String str = new String("小泽"); --&gt; &lt;bean id="str" class="java.lang.String"&gt; &lt;constructor-arg value="小泽"/&gt; &lt;/bean&gt; &lt;!-- 2. 使用setter方法注入 --&gt; &lt;!-- property: 通过调用setter进行赋值 name: setter方法名称。去掉set，把首字母小写 --&gt; &lt;bean id="person" class="com.gemin.pojo.Person"&gt; &lt;property name="id" value="666"/&gt; &lt;property name="username" ref="str"/&gt; &lt;/bean&gt;&lt;/beans&gt; 3.测试 1234567891011121314151617181920package com.gemin.test;import com.gemin.pojo.Person;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 演示依赖注入 */public class Demo4 &#123; @Test public void test1()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean_di.xml"); Person person = (Person)ac.getBean("person"); System.out.println(person); &#125;&#125; No.11 SpringIOC容器(七)依赖注入C-p名称空间分析 p名称空间注入，本质也是setter方法注入。 实现 步骤： 1.给Person类提供setter方法 2.配置bean.xml 3.测试 实现： 1.给Person类提供setter方法 2.配置bean.xml 先导入p名称空间 3.测试 1234567891011121314151617181920package com.gemin.test;import com.gemin.pojo.Person;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 演示依赖注入 */public class Demo4 &#123; @Test public void test1()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean_di.xml"); Person person = (Person)ac.getBean("person"); System.out.println(person); &#125;&#125; No.12 SpringIOC容器(八)给集合属性赋值实现 步骤： 1.在Person类提供一些集合类型 2.配置bean.xml 3.测试 实现： 1.在Person类提供一些集合类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.gemin.pojo;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;/** * */public class Person &#123; //定义属性 private int id; private String username; private String sex; public Person()&#123; System.out.println("创建Person对象！！"); &#125; //方式一：使用带参数的构造方式进行属性的依赖注入 public Person(int id,String username)&#123; this.id = id; this.username = username; &#125; public Person(String sex,String username)&#123; this.sex = sex; this.username = username; &#125; //方式二：使用setter方法对属性辅助 public void setId(int id) &#123; System.out.println("调研Person的setId"); this.id = id; &#125; public void setUsername(String username) &#123; System.out.println("调研Person的setUsername"); this.username = username; &#125; //集合类型 private List&lt;String&gt; list; private Set&lt;String&gt; set; private Map&lt;String,String&gt; map; private String[] array; private Properties properties; public void setSex(String sex) &#123; this.sex = sex; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void setSet(Set&lt;String&gt; set) &#123; this.set = set; &#125; public void setMap(Map&lt;String, String&gt; map) &#123; this.map = map; &#125; public void setArray(String[] array) &#123; this.array = array; &#125; public void setProperties(Properties properties) &#123; this.properties = properties; &#125; @Override public String toString() &#123; return "Person&#123;" + "id=" + id + ", username='" + username + '\'' + ", sex='" + sex + '\'' + '&#125;'; &#125;&#125; 2.配置bean.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- 集合类型注入 --&gt;&lt;bean id="person" class="com.gemin.pojo.Person"&gt; &lt;!-- 1.注入List --&gt; &lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;小苍&lt;/value&gt; &lt;value&gt;小泽&lt;/value&gt; &lt;ref bean="str"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--2.注入Set --&gt; &lt;property name="set"&gt; &lt;set&gt; &lt;value&gt;小苍&lt;/value&gt; &lt;value&gt;小玛&lt;/value&gt; &lt;ref bean="str"/&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--3.注入Map --&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="1001" value="小苍"&gt;&lt;/entry&gt; &lt;entry key="1002" value="小玛"&gt;&lt;/entry&gt; &lt;entry key="1003" value-ref="str"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 4.注入数组 --&gt; &lt;property name="array"&gt; &lt;array&gt; &lt;value&gt;小苍&lt;/value&gt; &lt;value&gt;小泽&lt;/value&gt; &lt;ref bean="str"/&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- 5.注入Properties 注意：Properties 类型不能使用ref引用类型 --&gt; &lt;property name="properties"&gt; &lt;props&gt; &lt;prop key="1001"&gt;小苍&lt;/prop&gt; &lt;prop key="1002"&gt;小泽&lt;/prop&gt; &lt;prop key="1003"&gt;小玛&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 3.测试 1234567891011121314151617181920package com.gemin.test;import com.gemin.pojo.Person;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 演示依赖注入 */public class Demo4 &#123; @Test public void test1()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean_di.xml"); Person person = (Person)ac.getBean("person"); System.out.println(person); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>IOC</tag>
        <tag>Spring Framework</tag>
        <tag>DI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE之常量、变量、数据类型、运算符]]></title>
    <url>%2FJavaSE%E4%B9%8B%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[N0.1 基本概念 关键字的研究什么是关键字？ 1.关键字其实就是一些英文单词，是sun公司自己占用的，具有特殊含义和特殊功能以及特殊用途的。 2.注意：关键字不能被程序员拿来定义类名，方法名或者变量名称等。 识别关键字 关键字一般会高亮 随自己接触Java知识的加深，以后自己就能辨别 标识符的研究什么是标识符？ 1.标识符是Java中为类名或者变量名称或者方法名称等命名的规范。（程序员必须遵循这个规范） 标识符的组成规范 1.一般是由字符（一般是英文，中文也可以但是不规范），数字，下划线，美元符$组成2.强制性要求：数字不能开头。3.区分大小写的。 abc Abc是不一样的。4.标识符不能是关键字。 常量的概念和使用什么是常量？ 是指在Java程序中固定不变的数据，常量是一旦确定了值就无法改变的。 就是实际生活中的一些确定值：3.14 , 100 , “迪丽热巴”, true , false 常量有哪些？ 常量的分类 示范 整数常量 100，0，2 小数常量 3.14，99.8，88.8 字符常量 'A'，'b'，'8'，'中' (只能是单个字符必须用单引号围起来) 字符串常量 "我是中国人"，"12345"，"abcde" (必须用双引号围起来) 布尔常量 true，false (真或假) 空常量 null No.2 变量的基本概念 变量的概念和定义什么是变量? 变量是内存中的一块区域，其值在一定范围内可以发生改变的量。可以把变量理解成一个瓶子，只能装一个特定类型的数据。 变量的作用? 可以在程序执行的过程中，存储数据，操作数据，传输数据，分析数据等。都需要用变量存储这个数据。 如何定义变量？ 变量的定义格式 ： 数据类型 变量名称 = 初始值; 格式解析： 数据类型: 申明变量存储数据的具体类型，什么类型的变量就只能存放什么类型的数据。 变量名称：变量必须有名字别人才可以使用和访问，变量的名字的首字母应该小写。满足“驼峰模式”， stuAge className 初始值：可有可无，但是必须与数据类型保持一致。什么类型的变量存储什么类型的数据。 1234567891011/*示例*/public class VariableDemo01&#123; public static void main(String[] args)&#123; // 数据类型 变量名称 = 初始值; int age = 22 ; // 变量的类型int整型，age是变量的名称 22是初始值 =是赋值 System.out.println(age); // 22 age = 100 ; System.out.println(age); // 100 &#125;&#125; 数据类型的概念引入变量的格式：数据类型 变量名称 = 初始值 数据类型到底有哪些 Java的数据类型大体分为2大类：基本数据类型，引用数据类型。 基本数据类型(4大类8大种) 类型 对应为 数据范围 占用内存 整数类型 byteshortint(默认)long -128~127-32768~32767-2^31~2^31-1-2^63~2^63-1 1字节2字节4字节8字节 浮点型(小数) float(单精度)double(默认双精度) 1.4E-45~3.4028235E384.9E-324~1.7976931348623157E308 4字节8字节 字符型 char \u0000(即为0)\uffff(即为65,535) 2字节 布尔型 boolean truefalse 未定 引用数据类型：数组，类，接口等，只要不是基本数据类型那么就是引用数据类型 数据大小单位的换算 计算机的底层都是二进制：0 ，1 开关。一个开关只能表示2种信息。男女二个开关可以表示4个信息。 计算机认为8个开关是8位，一个开关称为1位。一位叫1b.1个字节等于8位，字节的单位的B , 位的但是b.1B = 8b1K = 1024 = 2^10/——————————————- 1KB = 1024B = 10248个开关。1MB = 10241024B1GB = 1024 10241024B = 1024MB1TB = 10241024 *10241024B = 1024GB TIP:开发中我们还是会选择用int定义整型，（默认）。开发中我们还是会选择用double定义小数，（默认）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 /*示例*/ public class VariableDemo02&#123; public static void main(String[] args)&#123; // 数据类型 变量名称 = 初始值; // 1.字节型 byte age1 = 23; byte age2 = 127; //byte age3 = 128; // 报错，越界了， -128-127 System.out.println(age1); // 23 System.out.println(age2); // 127 // 2.短整型 short st = 2333; System.out.println(st); // 3.整型 int money = 10000000; System.out.println(money); long lg = 232323233; System.out.println(lg); // 4.长整型 /** 注意语法：随便写一个整数常量，默认是int类型的 323232323232332323其实是int类型的，323232323232332323虽然没有超过long的范围，但是它超过了int的范围 所以报错，那么如果希望随便写一个整数常量默认是long类型的，需要在整数后面加上L或者l. */ long nums = 323232323232332323L; System.out.println(nums); // 5.单精度小数 /** 注意语法：随便写一个小数常量，默认是double类型的 5.33其实是double类型的,如果希望随便写一个小数默认是float类型就应该在小数后面加上F或者f 所以 */ float ft = 5.33F; System.out.println(ft); // 6.双精度小数 double db = 3.14 ; System.out.println(db); // 7.布尔型 boolean flag1 = true ; boolean flag2 = false ; System.out.println(flag1); System.out.println(flag2); // 8.字符类型的变量 char c1 = 'a'; char c2 = '中'; char c3 = '中国'; // 直接报错! System.out.println(c1); System.out.println(c2); &#125;&#125; 变量的使用注意事项 1.变量必须定义才可以使用。变量的作用从定义开始到 } 结束2.同一个范围内不能定义两个同名的变量名称。冲突！！ 1234567891011121314151617/*示例*/public class VariableDemo03&#123; public static void main(String[] args)&#123; //System.out.println(age); // 报错!! // 变量的作用从定义开始到&#125;结束 int age = 12 ; System.out.println(age); //int age = 100 ; // 报错 &#123; int num = 111; System.out.println(num); &#125; // System.out.println(num); // 报错 &#125;&#125; 数据类型转换-自动类型转换前言 Java认为不同的变量和常量在一起运算后的结果的类型必须统一。所以不同类型之间是存在类型转换的。 数据类型的转换方式：（1）自动类型转换。（2）强制类型转换。（3）表达式的自动类型提升。 自动类型转换的语法规则： 数据如果在变量的类型范围之内是可以直接自动类型转换的。 小范围类型的变量可以自动类型转换给大范围类型的变量 类型范围：由小到大 byte -&gt; short -&gt; char -&gt; int -&gt; long -&gt; float -&gt; double 12345678910111213141516/*示例*/public class DataConvert&#123; public static void main(String[] args)&#123; // a.数据如果在变量的类型范围之内是可以直接自动类型转换的。 byte bt = 120 ; // -128 - 127 自动类型转换 //byte bt1 = 130 ; // 报错 System.out.println(bt); // b.小范围类型的变量可以自动类型转换给大范围类型的变量 byte age = 23 ; int it = age ; // 自动类型转换 System.out.println(age); // 23 System.out.println(it); // 23 &#125;&#125; 数据类型转换-强制类型转换强制类型转换的语法规则： 数据超过了对应变量的类型范围就必须进行手工的强制类型转换，否则代码报错！！ 大范围类型的变量赋值给小范围类型的变量必须进行手工强制类型转换，否则代码报错！ 强制类型转换的格式: 数据类型 变量 = (数据类型)数据或者变量 TIP:强制类型转换可能出现数据失真（数据溢出） 小数强制转换成整数，会直接截断小数部分，保存整数结果。 12345678910111213141516171819public class DataConvert&#123; public static void main(String[] args)&#123; // a.数据超过了对应变量的类型范围就必须进行手工的强制类型转换，否则代码报错！！ // byte bt = 127 ; // 没有问题，进行自动类型转换。 // 数据类型 变量 = (数据类型)数据或者变量; byte bt = (byte)200 ; System.out.println(bt); // -56 强制类型转换可能出现数据溢出，数据会失真!! // b.大范围类型的变量赋值给小范围类型的变量必须进行手工强制类型转换，否则代码报错！ int it = 30; byte rs = (byte)it ; // 强制类型转换 System.out.println(rs); // 30 // 拓展： double money = 99999.999; int it1 = (int)money; System.out.println(it1); // 结果是一个整数，小数强制转换成整数，会直接截断小数部分，保存整数结果。 &#125;&#125; 数据类型转换-表达式的自动类型提升表达式的自动类型提升语法规则：表达式：就是有+ - * / 以及变量和常量一起运算 表达式的最终结果类型是由表达式中的最高数据类型决定的，最高数据类型是什么，最终结果的数据类型就是什么。 在表达式中，byte short , char是直接提升成int运算的byte ， short ，char -&gt; int -&gt; long -&gt; float -&gt; double 123456789101112131415161718192021222324252627282930/*示例*/public class DataConvert&#123; public static void main(String[] args)&#123; byte b1 = 1 ; short b2 = 2; int b3 = 3 ; int rs = b1 + b2 - b3 ; System.out.println(rs); byte c1 = 10 ; int c2 = 100 ; float ft = 1.0F ; double rs1 = c1*c2 + ft + 1.0; System.out.println(rs1); // 面试题： byte a1 = 10 ; byte a2 = 100 ; // byte a3 = a1 + a2 ; // 代码会报错!在表达式中，byte short , char是直接提升成int运算的 int rs2 = a1 + a2 ; System.out.println(rs2); byte bt1 = 1 ; byte b12 = 2 double rs3 = bt1 + bt2 + 1.0; &#125;&#125; ASCLL编码表 计算机的底层是不能存储字符的。计算机的底层都是硬件。 计算机的底层只能存储二进制。0 1 2个开关可以表示4个信息 8个开关可以表示256个信息。 二进制就是整数 110 = 02^0 + 12^1 + 1*2^2 = 6 00 = 001 = 1^2^0 = 110 = 02^0 + 12^1 = 211 = 12^0 + 12^1 = 3 字符在底层存储的就是二进制。 美国人：为自己国家的字符做存储机制。美国人用每8个开关存储一个字符就够了。对于美国人来说够用了。 字符 对应整数 A 65 B 66 C 67 a 97 b 98 c 99 0 48 这套编码规则称为ASCII编码表。 TIP:字符在计算机底层其实就是一个编号。完全可以把字符当整数用。char的范围是小于int范围的。 123456789101112131415161718public class ASCIIDemo&#123; public static void main(String[] args)&#123; int rs = 'a' ; // 'a'的范围小于int,自动类型转换，把a字符的编号交给了int类型的变量rs. System.out.println(rs); // 97 int rs1 = 'A'; System.out.println(rs1); int rs2 = '磊'; System.out.println(rs2); // 30922 //30922如何转换成字符呢 int code = 30923; char c = (char)code; // 把编号恢复成字符！！ System.out.println(c); &#125;&#125; 运算符的研究什么是运算符 是对常量和变量进行运算的符号。运算符在表达式中经常使用。 Java的运算符有哪些 1.算术运算符2.赋值运算符3.比较运算符4.三元运算符 算术运算符：+ ， - ， * ， / ， % ， ++ ，-- 基本的算术运算符：+，-，*，/，% (取余) 自增自减运算符：++(自增), --(自减) ++ , -- 用在变量的运算上的，可以对变量进行+1 , -1++ , -- 在与变量单独运算的时候，放在变量的前后是没有区别的。都是对变量进行+1和-1操作。 ++ ， -- 在表达式中与变量运算的时候，放在变量前后是有差别的。 在表达式中，++，--如果放在变量的前面，会先对变量进行+1或者-1然后再拿变量的值进行运算。 在表达式中，++，--如果放在变量的后面，会先拿变量的值进行运算，然后再对变量的值进行+1或者-1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*示例*/public class OperatorDemo02&#123; public static void main(String[] args)&#123; /** 自增自减运算符: ++（自增） , --（自减） */ int a = 10 ; a++ ; // 原理：a = a + 1 System.out.println(a); //11 int b = 10 ; b-- ; // b = b -1 System.out.println(b); //9 int i = 10 ; ++i ; // i = i+ 1 System.out.println(i); //11 int j = 10 ; --j ; // j = j -1 System.out.println(j); //9 System.out.println("--------------------------------拓展------------------------------------"); /** c.++ ， -- 在表达式中与变量运算的时候，放在变量前后是有差别的。 在表达式中，++，--如果放在变量的前面，会先对变量进行+1或者-1然后再拿变量的值进行运算。 在表达式中，++，--如果放在变量的后面，会先拿变量的值进行运算，然后再对变量的值进行+1或者-1 */ int m = 10 ; int rs = m++ ; // 先用再加 System.out.println(rs); // 10 System.out.println(m); // 11 int n = 10 ; int rss1 = ++n ; // 先加再用 System.out.println(rss1); // 11 System.out.println(n); // 11 System.out.println("--------------------------------拓展：面试题------------------------------------"); int k = 3 ; int p = 4 ; // k 3 4 3 2 3 // p 4 5 6 // rs1 4 - 3 - 5 + 6 - 3 - 3 +1 - 3 int rs1 = ++k - --k - ++p + ++p - k-- - ++k + 1 -k; System.out.println(rs1); // -6 System.out.println( k); // 3 System.out.println( p); // 6 &#125;&#125; +符号在字符和字符串中的操作总规则： +符号与字符串运算的时候是用作连接符的。+符号与任何字符串连接的结果依然是一个字符串。整数与字符做运算的直接拿值运算。不会做连接了！ TIP:能算则算，不能算就连接！！！！ 12345678910111213/*示例*/public class OperatorDemo03&#123; public static void main(String[] args)&#123; int a = 5 ; // + 遇到字符串表示连接 System.out.println("abc" + 'a'); // abca System.out.println("abc" + a); // abc5 System.out.println("abc" + 5 + 'a'); // abc5a System.out.println(15 + "abc" + 15); // 15abc15 System.out.println(a + 'a'); // 5 + 97 = 102 运算，单个字符就是整数。 System.out.println(a + 'a' + "Dlei"); // 102Dlei &#125;&#125; 赋值运算符 基本的赋值运算符：= 扩展的赋值运算符：+= , -= , = , /= , %=注意：扩展运算符自带强制类型转换a += b ; // 公式： a = (a的数据类型) (a+b);a -= b ; // 公式： a = (a的数据类型) (a-b);a *= b ; // 公式： a = (a的数据类型) (ab);a /= b ; // 公式： a = (a的数据类型) (a/b);a %= b ; // 公式： a = (a的数据类型) (a%b); 123456789101112131415/*示例*/public class OperatorDemo04&#123; public static void main(String[] args)&#123; int age = 12 ; // =就是赋值运算符，从右往左执行！ int a = 10 ; int b = 20 ; //int rs = a + b; //a+=b ; // a = (a的类型)(a+b); //a*=b ; // a = (a的类型)(a*b); //a%=b ; // a = (a的类型)(a%b); 10 % 3 = 1 25 % 3 = 1 10 % 20 = 10 a /= b ; // a = (a的类型)(a /b) System.out.println(a); &#125;&#125; 比较运算符 比较运算符又叫关系运算符，是两个数据之间进行比较的运算，运算结果都是布尔值true或者false 。 符号:&gt;&gt;=&lt;&lt;===!= TIP: 判断是否相等必须是“==”。不是“=” 比较运算符的结果一定是布尔类型的结果。false ，true 123456789101112131415161718192021222324252627282930/*示例*/public class OperatorDemo05&#123; public static void main(String[] args)&#123; // 做判断 int a = 10 ; int b = 11 ; System.out.println(a &gt; b); // false System.out.println(a &gt;= b); // false System.out.println(a &lt; b); // true System.out.println(a &lt;= b); // true System.out.println(a == b); // false 是否相等 System.out.println(a != b); // true 是否不相等 System.out.println("--------------------"); int a1 = 10 ; int b1 = 10 ; System.out.println(a1 &gt; b1); // false System.out.println(a1 &gt;= b1); // true System.out.println(a1 &lt; b1); // false System.out.println(a1 &lt;= b1); // true System.out.println(a1 == b1); // true 是否相等 System.out.println(a1 != b1); // false System.out.println("--------------------"); int c1 = 10 ; int c2 = 20 ; System.out.println(c1 = c2); // 20 ,这里在赋值输出，不是判断是否相等！ &#125;&#125; 1234567891011121314151617/** 运算符的练习题** 随便给你一个三位数，计算出它的个位，十位，和百位并输出显示。 898 */public class ExecDemo09&#123; public static void main(String[] args)&#123; int num = 898 ; // 输出个位 System.out.println("个位："+num % 10) ; // 8 // 输出十位 System.out.println("十位："+ (num / 10) % 10); // 9 // 输出百位 System.out.println("百位："+ num / 100); // 8.98 -&gt; 8 &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>变量</tag>
        <tag>常量</tag>
        <tag>数据类型</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE之初识Java]]></title>
    <url>%2FJavaSE%E4%B9%8B%E5%88%9D%E8%AF%86Java%2F</url>
    <content type="text"><![CDATA[No.1 初识Java Java语言概述什么是Java语言 Java语言是美国Sun公司（Stanford University Network/斯坦福大学网络公司），在1995年推出的高级的编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。Java可运行于多个平台，如Windows, Mac OS，及其他多种UNIX版本的系统。 Java语言能做什么Java的技术体系 Sun根据应用的领域不同把Java技术划归为三个平台，依次是Java SE，Java EE ，Java ME 1.Java SE Java SE 是Java平台标准版的简称（Java Platform, Standard Edition） ，用于开发和部署桌面、服务器以及嵌入设备和实时环境中的Java应用程序。Java SE包括用于开发Java Web服务的类库，同时，Java SE为Java EE和Java ME提供了基础。我们在基础阶段学习的技术都是属于Java SE领域的内容。 2.Java EE Java EE是Java平台企业版的简称（Java Platform Enterprise Edition），用于开发便于组装、健壮、可扩展、安全的服务器端Java应用。Java EE建立于Java SE之上，具有Web服务、组件模型、以及通信API等特性，这些为面向服务的架构（SOA）以及开发Web2.0应用提供了支持。我们在就业班和企业级应用技术属于这个领域。 3.Java ME Java ME是Java微版的简称（Java Platform Micro Edition），是一个技术和规范的集合，它为移动设备（包括消费类产品、嵌入式设备、高级移动设备等）提供了基于Java环境的开发与应用平台。 桌面应用程序 桌面程序的开发几乎不流行，Java并不擅长做桌面程序，Java可以做桌面程序。 嵌入设备中的应用程序大型互联网系统开发（Java的核心用途，工作的主要内容） Java语言主要应用在互联网程序的开发领域。常见的互联网程序比如天猫、京东、物流系统、网银系统等，以及服务器后台处理大数据的存储、查询、数据挖掘等也有很多应用。 Java不只是做web系统，可以做服务器，做数据分析系统，做视频监控视频，轨道，智慧城市。 Java是兼容并包的语言：体系很庞大，但是功能很丰富，有一站式解决方案，安全，可以做高并发系统 。 Java语言发展历史版本升级历史 詹姆斯•高斯林（James Gosling）1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得了美国卡内基梅隆大学计算机科学博士学位，毕业后到IBM工作，设计IBM第一代工作站NeWS系统，但不受重视。后来转至Sun公司，1990年，与Patrick，Naughton和Mike Sheridan等人合作“绿色计划”，后来发展一套语言叫做“Oak”，后改名为Java。Java是印度尼西亚爪哇岛的英文名称，爪哇岛因盛产咖啡而闻名。Java创始人员团队中其中一名成员想起自己在Java岛（爪哇岛）上曾喝过一种美味的咖啡。 1995年Sun公司发布Java1.0版本（初始化版本） 1997年发布Java 1.1版本 1998年发布Java 1.2版本 2000年发布Java 1.3版本 2002年发布Java 1.4版本 2004年发布Java 1.5版本 2006年发布Java 1.6版本 2009年sun帝国死了。Oracle甲骨文公司收购Sun公司，并于2011发布Java 1.7版本，所以Java从此之后一直由Oracle公司管理。 2014年发布Java 1.8版本 2017年发布Java 9.0版本 2018年发布Java 10.0版本 2019 年已经是 Java 12版本 No.2 Java开发环境介绍与搭建 Java的组成JVM(Java虚拟机) JVM（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，最终都运行在JVM 之上。 JRE JRE (Java Runtime Environment) ：是Java程序的运行时环境，包含JVM 和运行时所需要的核心类库。如果程序员想要运行一个已经开发好的Java程序，那么只需要安装好JRE即可。 JDK JDK(Java Development Kit) ：是Java程序开发工具包，包含JRE 和开发人员使用的工具。我们想要运行一个已有的Java程序，那么只需安装JRE 即可。我们想要开发一个全新的Java程序，那么必须安装JDK 。 小结 1.从上面的产品介绍可以看出，JRE是包括JVM加上运行类库的，JDK包含了编译器等开发工具如后续即将介绍的javac或者java命令工具然后在加上JRE的。 2.如果程序员想要运行一个已经开发好的Java程序，那么只需要安装好JRE即可。但如果想开发一个新的Java程序应该安装JDK。 3.简言之：使用JDK安装完成Java程序，交给JRE去运行即可。 4.因为JDK已经包含了JRE,所以我们需要安装JDK即可。 Java跨平台的原理 跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为Java语言的跨平台特性(“一次编写,处处运行”)。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。 Java语言之所以可以跨平台的根本原因是因为JVM虚拟机。Java程序运行在Java虚拟机上，每个操作系统下都有不同版本的虚拟机。 计算机的交互方式 人机交互技术是指通过计算机输入、输出设备，以有效的方式实现人与计算机对话的技术。计算机的交互方式包含可视化界面的方式（鼠标，键盘，触摸等操作）， 语音识别，体感技术等，CLI方式（字符操作界面）等形式。 可视化界面方式 显示器上的功能操作可以直接通过鼠标，键盘，触摸等完成。 语音识别，体感技术等 应用场景如天猫精灵，汽车系统服务，等。 CLI方式（字符操作界面） 在早期的DOS操作系统中，是需要通过字符操作界面书写命令操作计算机的，Java语言的初学者，学习一些DOS命令，会非常有帮助。DOS是一个早期的操作系统，现在已经被Windows系统取代，对于我们开发人员，目前还是需要在DOS中完成一些事情，因此就需要掌握一些必要的命令。 常用DOS命令 进入DOS操作窗口 按下Windows+R键盘，打开运行窗口，输入cmd回车，进入到DOS的操作窗口。 打开DOS命令行后，看到一个路径c:\user\xxx就表示我们现在操作的是c:\user\xxx这个文件夹。 常用命令 命令 操作符号 盘符切换 盘符名: 查看当前文件夹内容 dir 进入文件夹 cd 文件夹名 退出文件夹 cd.. 退出到磁盘根目录 cd\ 清屏 cls 系统时间 time 修改系统时间 date 注意:cd到其他盘的文件夹中还需要切换盘符DOS常用命令练习盘符切换:​D:/ JDK 9安装图解至此，我们已经讲解完了Java开发环境的所有准备知识，从上述内容中我们得出结论，进行Java开发，需要安装Java的产品JDK，以下是安装详解。 TIP： 安装路径中，不要包含中文和空格。因为计算机对中文和空格目录是比较敏感的，在以后的开发中可能这种安装形式会出现一些问题。 环境变量的配置什么是环境变量 虽然我们在上述步骤中已经安装好了JDK,但是操作系统并不知道我们JDK安装到了哪里，同时开发运行Java程序，需要使用JDK中提供的工具命令，工具在JDK9安装目录的bin 目录下。配置完环境变量后我们可以在任意的目录下都可以使用JDK的开发工具。 如果需要使用这些工具命令，在DOS命令行下是不能直接使用这些工具的，就要先进入到JDK的bin目录下才可以使用，这个过程就会非常的麻烦。 如果不进入JDK的bin目录，这些工具就不能使用，会报错。 为了开发方便，我们想在任意的目录下都可以使用JDK的开发工具，则必须要配置环境变量，配置环境变量的意义在于告诉操作系统，我们使用的JDK安装到了哪里，同时告诉操作系统我们的开发工具在哪个目录下。 配置环境变量步骤 上节中已经说明了环境变量的作用，我们需要配置JAVA_HOME说明Java的安装目录，我们同时也需要配置PATH环境变量说明Java的开发工具安装到了哪里，详细步骤如下： Windows 7/8版本安装步骤 计算机鼠标右键,选择属性 选择高级系统设置 高级 选项卡，点击环境变量 点击新建 ，创建新的环境变量 变量名输入JAVA_HOME，变量值输入JDK9的安装目录 c:\Java9\jdk-9.0.1 选中Path 环境变量，双击或者点击编辑 TIP: Path中C:\ProgrammaData\Oracle\Java...，该路径是安装后默认配置的路径，可以删除。 7.在变量值的最前面，键入%JAVA_HOME%\bin; 分号必须要写，必须是英文格式。 Windows 10版本安装步骤 文件资源管理器 –&gt; 此电脑鼠标右键 –&gt; 选择属性 选择高级系统设置 –&gt; 选择 环境变量 点击下方系统变量的 新建 ，创建新的环境变量，变量名输入JAVA_HOME，变量值输入JDK9的安装目录 C:\develop\Java\jdk-9.0.1 选中Path 环境变量，双击或者点击编辑 点击新建，键入%JAVA_HOME%\bin ，必须是英文格式。选中该行，上移到最上方，点击确定。 检测配置是否成功 1.环境变量配置完成，重新开启DOS命令行，在任意目录下输入javac 命令。 2.如果输入“Javac”命令有提示，接下来还需要输入“java -version”命令，看提示的版本号与安装是否一致，一致则说明安装最终已经成功。 No.3 第一个Java程序HelloWorld 程序开发步骤说明Java程序开发三步骤：编写（写代码）、编译（翻译）、运行（跑起来）。 编写HelloWorld源程序12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); &#125;&#125; 文件名必须是HelloWorld ，保证文件名和类的名字是一致的，注意大小写。 第一个HelloWord 源程序就编写完成了，但是这个文件是程序员编写的，JVM是看不懂的，也就不能运行，因此我们必须将编写好的Java源文件 编译成JVM可以看懂的字节码文件 。 编译HelloWorld源文件在DOS命令行中，进入Java源文件的目录d:\day01(根据你们自己的源文件目录)，使用javac 命令进行编译。 命令： 1javac Java源文件名.后缀名 举例： 1javac HelloWorld.java 编译成功后，命令行没有任何提示。打开d:\day01目录，发现产生了一个新的文件 HelloWorld.class，该文件就是编译后的文件，是Java的可运行文件，称为字节码文件，有了字节码文件，就可以运行程序了。 Java源文件的编译工具javac.exe，在JDK安装目录的bin目录下。但是由于配置了环境变量，可以再任意目录下使用。 运行HelloWorld程序在DOS命令行中，进入Java源文件的目录d:\day01，使用java 命令进行运行。 命令： 1java 类名字 举例： 1java HelloWorld java HelloWord 不要写 不要写 不要写 .class Java程序.class文件 的运行工具java.exe ，在JDK安装目录的bin目录下。但是由于配置了环境变量，可以再任意目录下使用java命令了。 入门程序小结编译和运行是两回事 编译：是指将我们编写的Java源文件翻译成JVM认识的class文件，在这个过程中，javac 编译器会检查我们所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功。 运行：是指将class文件 交给JVM去运行，此时JVM就会去执行我们编写的程序了。 关于main方法 main方法：称为主方法。写法是固定格式不可以更改。main方法是程序的入口点或起始点，无论我们编写多少程序，JVM在运行的时候，都会从main方法这里开始执行。 No.4 基本软件和基本概念 基本软件 前期阶段本人比较推荐Sublime或者notepad++进行Java代码的练习，后期阶段再使用专业的IDE集成工具IDEA、Eclipse等 注释comment注释是对代码解释和说明的文字。其目的是让人们能够更加轻松地了解代码。为代码添加注释，是十分必须要的，注释是给人看的，它不影响程序的编译和运行。 Java中的注释包含单行注释，多行注释和文档注释。 单行注释单行注释以 //开头 换行结束，每个单行注释只能注释一行注释信息。 多行注释多行注释以 /*开头 以*/结束，多行注释可以注释多行注释信息。 文档注释文档注释以/**开头 以*/结束,文档注释也可以注释多行信息。 三种注释的区别1.单行注释只能注释一行， 2.多行注释和文档注释都可以注释多行。 3.文档注释一般用于注释在类，方法，成员变量上（后续会遇到这些成员），文档注释的内容是可以提取到API文档中去的,下节将介绍如何生成API文档。 javadoc命令生成API文档 在d:\day01 目录下新建文本文件，完整的文件名修改为HelloWorld.java，其中文件名为HelloWorld，后缀名必须为.java 。 用记事本打开 在文件中键入文本并保存，代码如下： 123456789101112131415/** * @author Mr.Ge * @version 1.0 * 这个是一个入门的Java代码，这是我们的第一个代码HelloWord */public class HelloWorld &#123; /** * @param args * 这是程序的入口方法名称叫main * 这个方法启动的时候会自动执行 */ public static void main(String[] args) &#123; System.out.println("Hello,World!"); &#125;&#125; 打开DOS界面，进入到d:\day01目录下,输入 1javadoc -charset GBK HelloWorld.java 进入到d:/day01目录下。双击index.html，可以观察到文档注释的信息提取到了API文档中去]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>初识Java</tag>
        <tag>常用DOS</tag>
        <tag>JAVA_HOME配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse快捷键整理]]></title>
    <url>%2FEclipse%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Eclipse快捷键大全 Ctrl+1 快速修复(最经典的快捷键,就不用多说了) Ctrl+D: 删除当前行 Ctrl+Alt+↓ 复制当前行到下一行(复制增加) Ctrl+Alt+↑ 复制当前行到上一行(复制增加) Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了) Alt+↑ 当前行和上面一行交互位置(同上) Alt+← 前一个编辑的页面 Alt+→ 下一个编辑的页面(当然是针对上面那条来说了) Alt+Enter 显示当前选择资源(工程,or 文件 or文件)的属性 Shift+Enter 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置,不一定是最后) Shift+Ctrl+Enter 在当前行插入空行(原理同上条) Ctrl+Q 定位到最后编辑的地方 Ctrl+L 定位在某行 (对于程序超过100的人就有福音了) Ctrl+M 最大化当前的Edit或View (再按则反之) Ctrl+/ 注释当前行,再按则取消注释 Ctrl+O 快速显示 OutLine Ctrl+T 快速显示当前类的继承结构 Ctrl+W 关闭当前Editer Ctrl+K 参照选中的Word快速定位到下一个 Ctrl+E 快速显示当前Editer的下拉列表(如果当前页面没有显示的用黑体表示) Ctrl+/(小键盘) 折叠当前类中的所有代码 Ctrl+×(小键盘) 展开当前类中的所有代码 Ctrl+Space 代码助手完成一些代码的插入(但一般和输入法有冲突,可以修改输入法的热键,也可以暂用Alt+/来代替) Ctrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作) Ctrl+J 正向增量查找(按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在stutes line中显示没有找到了,查一个单词时,特别实用,这个功能Idea两年前就有了) Ctrl+Shift+J 反向增量查找(和上条相同,只不过是从后往前查) Ctrl+Shift+F4 关闭所有打开的Editer Ctrl+Shift+X 把当前选中的文本全部变味小写 Ctrl+Shift+Y 把当前选中的文本全部变为小写 Ctrl+Shift+F 格式化当前代码 Ctrl+Shift+P 定位到对于的匹配符(譬如{}) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反之) 下面的快捷键是重构里面常用的,本人就自己喜欢且常用的整理一下(注:一般重构的快捷键都是Alt+Shift开头的了) Alt+Shift+R 重命名 (是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力) Alt+Shift+M 抽取方法 (这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用) Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定) Alt+Shift+L 抽取本地变量( 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候) Alt+Shift+F 把Class中的local变量变为field变量 (比较实用的功能) Alt+Shift+I 合并变量(可能这样说有点不妥Inline) Alt+Shift+V 移动函数和变量(不怎么常用) Alt+Shift+Z 重构的后悔药(Undo) 编辑作用域&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;功能&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;快捷键全局&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找并替换&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ctrl+F文本编辑器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找上一个&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ctrl+Shift+K文本编辑器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找下一个&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ctrl+K全局&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;撤销&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ctrl+Z全局&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;复制&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ctrl+C全局&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恢复上一个选择&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alt+Shift+↓全局&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;剪切&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ctrl+X全局&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;快速修正&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ctrl1+1全局&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内容辅助&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alt+/全局&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;全部选中&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ctrl+A全局&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete全局&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上下文信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alt+？Alt+Shift+?Ctrl+Shift+SpaceJava编辑器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显示工具提示描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F2Java编辑器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择封装元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alt+Shift+↑Java编辑器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择上一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alt+Shift+←Java编辑器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择下一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alt+Shift+→文本编辑器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;增量查找&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ctrl+J文本编辑器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;增量逆向查找&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ctrl+Shift+J全局&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;粘贴&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ctrl+V全局&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重做&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ctrl+Y 查看作用域 功能 快捷键全局 放大 Ctrl+=全局 缩小 Ctrl+- 窗口作用域 功能 快捷键全局 激活编辑器 F12全局 切换编辑器 Ctrl+Shift+W全局 上一个编辑器 Ctrl+Shift+F6全局 上一个视图 Ctrl+Shift+F7全局 上一个透视图 Ctrl+Shift+F8全局 下一个编辑器 Ctrl+F6全局 下一个视图 Ctrl+F7全局 下一个透视图 Ctrl+F8文本编辑器 显示标尺上下文菜单 Ctrl+W全局 显示视图菜单 Ctrl+F10全局 显示系统菜单 Alt+- 导航作用域 功能 快捷键Java编辑器 打开结构 Ctrl+F3全局 打开类型 Ctrl+Shift+T全局 打开类型层次结构 F4全局 打开声明 F3全局 打开外部javadoc Shift+F2全局 打开资源 Ctrl+Shift+R全局 后退历史记录 Alt+←全局 前进历史记录 Alt+→全局 上一个 Ctrl+,全局 下一个 Ctrl+.Java编辑器 显示大纲 Ctrl+O全局 在层次结构中打开类型 Ctrl+Shift+H全局 转至匹配的括号 Ctrl+Shift+P全局 转至上一个编辑位置 Ctrl+QJava编辑器 转至上一个成员 Ctrl+Shift+↑Java编辑器 转至下一个成员 Ctrl+Shift+↓文本编辑器 转至行 Ctrl+L 搜索作用域 功能 快捷键全局 出现在文件中 Ctrl+Shift+U全局 打开搜索对话框 Ctrl+H全局 工作区中的声明 Ctrl+G全局 工作区中的引用 Ctrl+Shift+G 文本编辑作用域 功能 快捷键文本编辑器 改写切换 Insert文本编辑器 上滚行 Ctrl+↑文本编辑器 下滚行 Ctrl+↓ 文件作用域 功能 快捷键全局 剪切 Ctrl+X全局 保存 Ctrl+S全局 打印 Ctrl+P全局 关闭 Ctrl+F4全局 全部保存 Ctrl+Shift+S全局 全部关闭 Ctrl+Shift+F4全局 属性 Alt+Enter全局 新建 Ctrl+N 项目作用域 功能 快捷键全局 全部构建 Ctrl+B 源代码作用域 功能 快捷键Java编辑器 格式化 Ctrl+Shift+FJava编辑器 取消注释 Ctrl+\Java编辑器 注释 Ctrl+/Java编辑器 添加导入 Ctrl+Shift+MJava编辑器 组织导入 Ctrl+Shift+O Java编辑器 使用try/catch块来包围 未设置，太常用了，所以在这里列出,建议自己设置。也可以使用Ctrl+1自动修正。 运行作用域 功能 快捷键全局 单步返回 F7全局 单步跳过 F6全局 单步跳入 F5全局 单步跳入选择 Ctrl+F5全局 调试上次启动 F11全局 继续 F8全局 使用过滤器单步执行 Shift+F5全局 添加/去除断点 Ctrl+Shift+B全局 显示 Ctrl+D全局 运行上次启动 Ctrl+F11全局 运行至行 Ctrl+R全局 执行 Ctrl+U 重构作用域 功能 快捷键全局 撤销重构 Alt+Shift+Z全局 抽取方法 Alt+Shift+M全局 抽取局部变量 Alt+Shift+L全局 内联 Alt+Shift+I全局 移动 Alt+Shift+V全局 重命名 Alt+Shift+R全局 重做 Alt+Shift+Y]]></content>
      <categories>
        <category>Java开发IDE之Eclipse</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
</search>
